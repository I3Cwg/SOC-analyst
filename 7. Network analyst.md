

## ğŸŒ **Network Traffic Analysis (NTA)**

### ğŸ§  **What Is It?**  
**Network Traffic Analysis** is the process of **monitoring, collecting, and analyzing** traffic flowing through your network to:
- Detect threats ğŸ›¡ï¸  
- Identify anomalies ğŸ”  
- Understand normal behavior ğŸ“Š  
- Investigate incidents ğŸ”¦  

### ğŸ¯ **Main Purposes of NTA**  

1. **ğŸ‘ï¸ Monitor Network in Real-Time**  
   - Watch how systems communicate  
   - Detect signs of malicious activity as it happens

2. **ğŸ“ Set Baselines**  
   - Learn what "normal" looks like  
   - Helps spot unusual or suspicious behavior quickly

3. **ğŸš© Spot Anomalies and Misconfigurations**  
   - Suspicious IPs ğŸ•µï¸â€â™‚ï¸  
   - Unusual ports and protocols (e.g., HTTP errors, TCP issues)  
   - Misconfigured or unauthorized network services

4. **ğŸ§¬ Detect Malware "On the Wire"**  
   - Catch ransomware, exploits, and backdoor tools by observing communication patterns

5. **ğŸ”™ Support Threat Hunting & Incident Response**  
   - Analyze historical data to investigate attacks  
   - Trace the attack path or lateral movement

### ğŸ’£ **Why It Matters?**  
Attackers **must communicate** with your network to:
- Deliver payloads ğŸ¯  
- Move laterally â†”ï¸  
- Exfiltrate data ğŸ“¤

By analyzing traffic, you can **spot**:
- ğŸ‘¾ Port scanning (e.g., many SYN packets on unused ports)  
- ğŸ§ª Exploits or suspicious traffic  
- ğŸ§â€â™‚ï¸ Internal abuse or privilege misuse  
- ğŸ•³ï¸ Backdoors left open for command & control

### âš™ï¸ **Typical NTA Workflow**  

1. ğŸ“¡ **Collect** network traffic (e.g., via SPAN port, TAPs, or agents)  
2. ğŸ§  **Analyze** data using tools like Wireshark, Zeek, Suricata, or commercial NDR systems  
3. âš ï¸ **Alert** on known threats or anomalies  
4. ğŸ” **Investigate** and respond if malicious behavior is detected

### âœ… **Key Skills Needed**  
- Understand common protocols (HTTP, DNS, SMB, etc.)  
- Know normal traffic patterns in your network  
- Interpret packet data and identify red flags  
- Use packet analysis tools efficiently

---

## ğŸ› ï¸ **Required Skills & Knowledge for NTA**

> ğŸ”‘ *You donâ€™t need to memorize everythingâ€”just know what to look for and where.*  
> These skills are essential not just for NTA, but for cybersecurity as a whole.

### ğŸŒ 1. **TCP/IP Stack & OSI Model**
ğŸ“¦ Understand how data travels from application to network and back.  
ğŸ§© Helps connect how apps â†”ï¸ networks work together.

- **OSI Model (7 layers)** = ğŸ“¡ Physical â†’ ğŸ’¾ Application  
- **TCP/IP Model (4 layers)** = ğŸŒ Network Interface â†’ ğŸ“¬ Application

> ğŸ§  *Helps interpret where an issue occurs and what layer to investigate.*

### ğŸ›œ 2. **Basic Network Concepts**
ğŸ”„ Switching vs Routing  
ğŸ¢ Office traffic â‰  Backbone traffic

- Switch = Local traffic â†”ï¸  
- Router = Internet/Network gateways ğŸŒ

> ğŸ“ *Know where youâ€™re tapping into the networkâ€”context matters!*

### ğŸ“Š 3. **Common Ports & Protocols**
ğŸ¯ Recognize standard ports like:
- 80 (HTTP) ğŸŒ  
- 443 (HTTPS) ğŸ”  
- 53 (DNS) ğŸ”  
- 445 (SMB) ğŸ“  

> ğŸ§  *Quick ID of protocols helps detect suspicious or unexpected behavior.*

### ğŸ“¦ 4. **IP Packets & Sublayers**
ğŸ§© Know how TCP & UDP differ:

- **TCP** = Reliable, ordered, connection-based ğŸ”  
  â†’ Great for tracking conversations between hosts  
- **UDP** = Fast, connectionless, no guarantee ğŸš€  
  â†’ Harder to reconstruct full sessions

> ğŸ” *Understand packet structure = better detection of weird or malformed data.*

### ğŸ” 5. **Protocol Transport Encapsulation**
ğŸ§± Each layer wraps the data of the previous (like nesting dolls ğŸª†):

- Ethernet (frame) â†’ IP (packet) â†’ TCP (segment) â†’ App Data

> ğŸ§  *Spotting when headers change can reveal tunneling, misbehavior, or attacks.*

### ğŸ“ Final Tip:
You donâ€™t need to **master** everything at once â€” but building **familiarity** with these areas will level up your network threat detection skills significantly.


### ğŸŒ **Environment and Equipment for Network Traffic Analysis**

To perform **Network Traffic Analysis (NTA)** effectively, there are various tools and equipment that help capture, inspect, and analyze network traffic. Each tool serves a different purpose â€” some are designed to **capture live traffic**, others to **analyze saved data**, and some can even **reassemble streams or visualize large datasets**.

> âš ï¸ **Note**: These tools are not just for administrators. Attackers can also misuse them for malicious purposes.

### ğŸ§° **Common Traffic Analysis Tools**

| ğŸ› ï¸ **Tool** | ğŸ” **Description** |
|-------------|--------------------|
| **tcpdump** | A command-line tool that captures and interprets network traffic using **LibPcap**. Lightweight and commonly used on Linux. |
| **TShark** | The command-line version of Wireshark. It can capture live traffic or read from a file and **decode packets**. Similar to tcpdump but more detailed. |
| **Wireshark** | A powerful **graphical network traffic analyzer**. It decodes packets and displays detailed protocol information using multiple dissectors. |
| **NGrep** | Works like the `grep` command but for network traffic. Supports **regular expressions** and **BPF syntax** to find patterns in HTTP, FTP, and other protocols. |
| **tcpick** | A command-line sniffer specialized in **tracking and reassembling TCP streams**. It can reconstruct files from TCP connections. |
| **Network Taps** | Hardware devices (e.g., Gigamon, Niagara Taps) that **copy network traffic** and send it elsewhere for analysis. Can be inline or passive. |
| **SPAN Ports** | A feature on switches/routers that **mirrors traffic** to a specific port for monitoring or logging purposes. Often used to collect traffic for external analysis. |
| **Elastic Stack** | A collection of tools (Elasticsearch, Logstash, Kibana) that **ingests, stores, and visualizes** large amounts of data, including network logs. |
| **SIEMs (e.g., Splunk)** | Central platforms for **analyzing, visualizing, alerting**, and performing **forensic investigations** based on network and system data. |


## ğŸ§ª **Performing Network Traffic Analysis (NTA)**

### ğŸ“¡ **What is it?**
Performing NTA can be as simple as watching live network traffic scroll through your terminal, or as complex as capturing traffic using a network tap and analyzing it through tools like a **SIEM** (Security Information and Event Management).

### âš™ï¸ **Basic Requirements**
To **passively capture traffic**, you must be:
- ğŸ“ **Connected to the right network segment** (especially important in switched networks using VLANs).
- ğŸ§· Use tools like **network taps**, **SPAN ports**, or **port mirroring** to get copies of traffic across network links â€” even if your capture device isnâ€™t the final destination.

### ğŸ”„ **NTA Workflow (Step-by-Step)**

Although Network Traffic Analysis is not always a straightforward or linear process, hereâ€™s a typical workflow to follow:

![alt text](image-32.png)

### **1. Ingest Traffic** ğŸ§²  
Start by **capturing the traffic** on your target network segment.  
- Use **filters** (like BPF filters in Wireshark or tcpdump) if you're looking for something specific (e.g., traffic on a certain port or from a certain host).

### **2. Reduce Noise by Filtering** ğŸ”‡  
Network traffic can be very **noisy**, especially in large or production environments.  
- Filter out unnecessary data like **broadcast** or **multicast** packets to focus on what matters.
- This step makes the analysis more efficient and readable.

### **3. Analyze and Explore** ğŸ”  
Now start digging into the **relevant data**. Ask questions like:
- ğŸŸ¡ **Is the traffic encrypted or plaintext?** (e.g., HTTP vs HTTPS)
- ğŸŸ  **Are users accessing resources they shouldnâ€™t?**
- ğŸ”µ **Are unusual host-to-host communications happening?**
- âš ï¸ **Check protocol flags** (like TCP SYN, ACK) to detect scans or unusual behavior.

### **4. Detect and Alert** ğŸš¨  
- â— Look for **errors or communication failures** (e.g., a server not responding).
- ğŸ›‘ Decide if the traffic is **normal or suspicious/malicious**.
- ğŸ” Use tools like **IDS/IPS** (e.g., Snort, Suricata) to automatically inspect traffic for known signatures and anomalies.

### **5. Fix and Monitor** ğŸ”§ğŸ‘€  
- After resolving a detected issue (e.g., patching a system, blocking a port), you must **keep monitoring** the affected area to confirm:
  - âœ… The problem is truly fixed
  - ğŸš« No further abnormal behavior occurs

---

#  Networking Primer - Layers 1-4


### ğŸ“ **Purpose of This Section**
This section is a **quick refresher** to help you understand the **basic networking concepts** you'll encounter when analyzing network traffic. Without understanding protocols, ports, and packet structures, it's impossible to properly interpret what you capture in tools like Wireshark or tcpdump.


## ğŸ§± **OSI vs. TCP/IP Models**

![alt text](image-33.png)

### ğŸ§© **What Are They?**

These models describe how **data travels** from one computer to another across a network. They're **frameworks** that break down communication into **layers**, each handling a specific part of the process.

### ğŸ” **Comparison Table**

| Trait         | OSI Model                    | TCP/IP Model                     |
|--------------|------------------------------|----------------------------------|
| **Layers**    | 7 Layers                     | 4 Layers                         |
| **Flexibility** | Strict structure             | More flexible                    |
| **Design**     | Protocol-independent, conceptual | Built from real-world protocols |

### ğŸ—‚ï¸ **Layer Mapping**

- **OSI Layers (7):**  
  1. Physical  
  2. Data Link  
  3. Network  
  4. Transport  
  5. Session  
  6. Presentation  
  7. Application  

- **TCP/IP Layers (4):**  
  1. Link  
  2. Internet  
  3. Transport  
  4. Application

> ğŸ§  Think of the **OSI model** as a **theoretical model** (used for understanding concepts), while the **TCP/IP model** is more **practical**, based on how real networks function.

## ğŸ“¦ **What Is a PDU (Protocol Data Unit)?**

A **PDU** is a **packet of data** that includes:
- **Control information** (headers, flags, etc.)
- **Encapsulated data** from higher layers

Each layer of the model **adds its own header** to the packet as it moves **down the stack**. This process is called **encapsulation**.

### ğŸ§Š **Encapsulation Example**
![alt text](image-34.png)
- At the **Application Layer**, your message might just be: "GET /index.html"
- At the **Transport Layer**, it adds a **TCP header** with source and destination **ports**
- At the **Network Layer**, it adds an **IP header** with source/destination **IP addresses**
- At the **Link Layer**, it adds **MAC addresses** and maybe **frame checksums**

Each layer **wraps** the previous data like layers of an onion.
### ğŸ§ª **Viewing PDUs in Wireshark**
![alt text](image-35.png)
In Wireshark:
- PDUs are shown **in reverse** order â€” because youâ€™re viewing how the data is **unwrapped** during analysis.
- Youâ€™ll see:  
  Ethernet â IP â TCP â HTTP â Payload

This unwrapping is called **decapsulation**.
### âœ… **Why This Is Important**
Understanding the structure of PDUs and how protocols work helps you:
- Recognize malicious behavior or anomalies in captured traffic
- Interpret logs and alerts more accurately
- Debug network issues more efficiently

Here's a **clear explanation in English** of the "Addressing Mechanisms" section, focusing on **MAC addressing** and how it works in a network:

---

## ğŸ“¬ **Addressing Mechanisms in Networking**

To ensure data reaches the correct device on a network, we use **addressing mechanisms**. These are identifiers used to deliver data across different network layers. One of the most foundational mechanisms is the **MAC address**.

### ğŸ§¾ **What Is a MAC Address?**

A **MAC (Media Access Control) address** is a **unique identifier** assigned to a network interface (like a network card or Wi-Fi adapter). It is:

- **48 bits long**
- Usually displayed as **6 groups** of **2 hexadecimal digits**, like:  
  `00:1A:2B:3C:4D:5E`
- Set by the **manufacturer** of the device (also known as a **burned-in address**)

### ğŸŒ **Where Is the MAC Address Used?**

- The MAC address operates at **Layer 2** of the OSI model (the **Data Link Layer**)
- It's used for **host-to-host communication** **within the same local network** (also known as a **broadcast domain**)
- Devices use MAC addresses to **send frames** to each other within a LAN

### ğŸ“¦ **MAC Address in Action**

Letâ€™s walk through an example:

1. **Your computer** wants to send data to another device on the same network.
2. It uses the **MAC address** of that destination device to send the frame.
3. If the destination is **outside the local network**, it sends the data to the **default gateway** (usually a router).
4. The router:
   - Strips off the original Layer 2 information.
   - Adds **new MAC address information** for the **next hop**.
   - Forwards the data based on **IP addresses** at Layer 3.

> ğŸ§  In short, MAC addresses are used **within the same network**, while IP addresses are used to **navigate between networks**.

### ğŸ” **How MAC Addresses Help in Routing**

When a packet needs to leave the local network:
- The device sends it to the router using the **routerâ€™s MAC address**.
- The router then:
  - Reads the **Layer 3 (IP)** destination address,
  - Decides where to send it,
  - **Replaces** the Layer 2 MAC address with the one for the **next destination**.

This process continues until the packet reaches its final destination.

### âœ… **Why This Is Important**

Understanding MAC addressing is essential for:
- **Troubleshooting** network issues (e.g., ARP problems, duplicate MACs)
- **Network security** (e.g., MAC filtering, identifying spoofed addresses)
- **Traffic analysis** (MAC addresses are visible in packet captures)

--- 
Hereâ€™s a **clear explanation in English** of the "IP Addressing" section, broken down for easy understanding:

---

## ğŸŒ **IP Addressing**

To send data across different networks (not just within a local network), we need a global system to identify devices. Thatâ€™s where **IP (Internet Protocol)** comes in. It helps **route data between networks** by using **IP addresses**.

### ğŸ“¡ **What Is IP?**

- IP is a **connectionless protocol** that:
  - Routes packets from source to destination across networks.
  - Splits and reassembles large data into smaller chunks (datagrams).
  - Works with other protocols like **TCP** to guarantee delivery (since IP itself doesnâ€™t).
- Operates at:
  - **Layer 3 (Network)** of the OSI model.
  - **Internet layer** of the TCP/IP model.

### ğŸ”¢ **IPv4 (Internet Protocol version 4)**

![alt text](image-36.png)

- **Most commonly used version** of IP today.
- Address length: **32-bit** â†’ shown as **four numbers (octets)** separated by dots (e.g., `192.168.1.1`)
- Each number ranges from **0 to 255**.
- Example: `192.168.86.243`
- IPv4 is essential for **routing data across different networks**.

### âš ï¸ **Why IPv4 Isnâ€™t Enough Anymore**

- IPv4 allows for **about 4.3 billion unique addresses**, which seemed a lotâ€”but we ran out quickly due to:
  - Growth of the internet.
  - Reserved/private address spaces.
  - Devices needing unique addresses.
- **Solutions attempted:**
  - **VLSM (Variable Length Subnet Masking)** and **CIDR (Classless Inter-Domain Routing)** to use addresses more efficiently.
  - But even those werenâ€™t enough.

### ğŸ§® **IPv6 (Internet Protocol version 6)**

- Created to **replace IPv4** and solve the address exhaustion problem.
- Address length: **128-bit** â†’ shown as **eight groups of four hexadecimal digits** (e.g., `2001:0db8:85a3:0000:0000:8a2e:0370:7334`)
- Can support **~340 undecillion addresses** â€” enough for every grain of sand on Earth to have its own IP!

### ğŸš€ **Benefits of IPv6**

- **Larger address space** for future growth.
- **Built-in security features** like **IPSec**.
- **Simplified packet headers** make processing faster.
- **Supports multicasting** better than IPv4.
- **Each device can have a global address**â€”no need for NAT (Network Address Translation).

### ğŸ“¬ **IPv6 Address Types**

| **Type**   | **Description**                                                                 |
|------------|----------------------------------------------------------------------------------|
| **Unicast**   | One-to-one: sent from one device to one specific device.                        |
| **Anycast**   | One-to-many (but only one responds): good for **load balancing**.               |
| **Multicast** | One-to-many: all devices in the group receive the same packet.                 |
| **Broadcast** | Doesnâ€™t exist in IPv6 (unlike IPv4); replaced by multicast instead.            |

### ğŸ“‰ **Adoption of IPv6**

- Even though IPv6 is technically superior, adoption has been **slow**.
- As of now, only about **40% of internet traffic globally** uses IPv6 (according to Google).

### âœ… **Quick Summary**

| **Feature**      | **IPv4**                          | **IPv6**                                 |
|------------------|-----------------------------------|------------------------------------------|
| Address Length   | 32-bit                            | 128-bit                                  |
| Format           | Decimal (e.g., 192.168.1.1)       | Hexadecimal (e.g., 2001:db8::1)          |
| Total Addresses  | ~4.3 billion                      | ~340 undecillion                        |
| Broadcast        | Yes                               | No (uses multicast instead)              |
| Built-in Security| No                                | Yes (via IPSec)                          |
| Adoption Rate    | Still dominant                    | Growing (~40% globally)                  |

---
## ğŸš¦ **TCP / UDP, Transport Mechanisms**

The **Transport Layer** is like the **traffic controller** of your dataâ€”it decides **how** the data moves between devices and makes sure it gets to the right place in the right order (or not, depending on the protocol used).

There are **two main transport protocols**:
1. **TCP (Transmission Control Protocol)** â€“ reliable, slower
2. **UDP (User Datagram Protocol)** â€“ fast, but unreliable

### ğŸ” **TCP â€“ Reliable and Connection-Oriented**

- **Connection-based:** TCP sets up a connection using a **three-way handshake** (like saying: â€œHello? You there? Yes? Okay, let's talk!â€).
- **Reliable:** Every packet sent is **acknowledged**. If a packet is lost, TCP will **retransmit** it.
- **Ordered:** Packets are **numbered** so they can be reassembled in the correct order.
- **Slower**, but **safer**â€”great when **data accuracy matters**.

#### âœ… Example use cases:
- **SSH (Secure Shell):** You wouldnâ€™t want to lose parts of a command like `sudo passwd user`!
- **Web browsing (HTTP/HTTPS):** You want to see the full webpage, not pieces missing.

### ğŸš€ **UDP â€“ Fast and Connectionless**

- **Connectionless:** No handshake. Just sends the packet and forgetsâ€”**"fire and forget"** style.
- **No acknowledgments or retransmissions**â€”UDP doesn't care if the packet got there or not.
- **Much faster**, but with **no guarantee** it got delivered or in order.
  
#### âš¡ Example use cases:
- **Video streaming (e.g., YouTube):** Itâ€™s okay if a few pixels dropâ€”you want smooth playback, not perfect frames.
- **DNS (Domain Name System):** A fast queryâ€”if it fails, just ask again.

### ğŸ§  **Quick Comparison: TCP vs UDP**

| **Feature**                | **TCP**                              | **UDP**                             |
|---------------------------|---------------------------------------|-------------------------------------|
| **Connection**            | Connection-oriented (3-way handshake) | Connectionless                      |
| **Reliability**           | Reliable (acknowledges packets)       | Unreliable (no acknowledgment)      |
| **Speed**                 | Slower (more overhead)                | Faster (less overhead)              |
| **Use Case**              | SSH, HTTP, file transfers             | Streaming, gaming, DNS              |
| **Error Handling**        | Yes                                   | No                                  |
| **Packet Order**          | Maintains order                       | May arrive out of order or not at all |

### ğŸ¯ When to Use What?

- **Use TCP** when:
  - You **need all the data**, intact and in order.
  - Examples: **Web, remote login, email, file transfers**.

- **Use UDP** when:
  - You **donâ€™t need perfect delivery**, just **speed**.
  - Examples: **Video calls, live streams, online gaming, DNS**.

### ğŸ§© Real-World Analogy

| TCP                              | UDP                              |
|----------------------------------|----------------------------------|
| Like sending a **registered letter** (signature needed) | Like tossing a **postcard** in the mail |
| Slower, but you know it got there | Fast, but no guarantee            |
---
## ğŸ” **TCP Three-Way Handshake** â€“ *How a Connection is Established*

Think of this like **starting a polite conversation** between two people (a client and a server). You donâ€™t just start talkingâ€”you say hello first, they respond, then you both agree to talk. In networking, this is how TCP ensures a **reliable connection** is made before sending data.

### ğŸ“¦ **Step-by-step: How the 3-Way Handshake Works**

1. **Client â¡ï¸ Server: SYN (Synchronize)**
   - The **client** wants to start a session, so it sends a packet with the `SYN` flag.
   - It includes a **sequence number** (like a label for the conversation).
   - Also negotiates things like window size and maximum segment size (how much data can be sent at once).

2. **Server â¡ï¸ Client: SYN-ACK (Synchronize + Acknowledge)**
   - The **server** receives the SYN, agrees to start the session.
   - It sends back a **SYN** (for its own sequence number) and an **ACK** (to acknowledge the clientâ€™s SYN).

3. **Client â¡ï¸ Server: ACK (Acknowledge)**
   - The **client** acknowledges the serverâ€™s response.
   - Now the session is established, and both sides can start sending actual data!

### ğŸ’¡ Real-World Analogy

![alt text](image-37.png)

Imagine two people trying to start a phone call:

- ğŸ“ **Person A (Client)**: "Hey, can we talk?" (`SYN`)
- ğŸ“ **Person B (Server)**: "Sure, I hear you. Let's talk!" (`SYN-ACK`)
- ğŸ“ **Person A**: "Cool, we're connected!" (`ACK`)

Now they can talk normally (exchange data).

### ğŸŒ Example in Networking

- Port `57678`: Random high port on client
- Port `80`: HTTP port on the server
- Packets:
  - Line 1: Client â†’ Server (`SYN`)
  - Line 2: Server â†’ Client (`SYN-ACK`)
  - Line 3: Client â†’ Server (`ACK`)
  - Line 4: Real data starts flowing (e.g., an HTTP request for a web page)

## ğŸ“´ **TCP Session Teardown** â€“ *How a Connection is Gracefully Closed*

Just like you **donâ€™t hang up the phone without saying goodbye**, TCP also politely ends conversations using the **FIN** (Finish) and **ACK** flags.

![alt text](image-38.png)
### ğŸ”š **Steps for Closing a TCP Connection**

1. **FIN, ACK** â€“ One side says, â€œIâ€™m done sending data.â€
2. **FIN, ACK** â€“ The other side replies, â€œGot it, and Iâ€™m done too.â€
3. **ACK** â€“ Final acknowledgment. The session is now closed.

### ğŸ’¡ Analogy for Teardown

Like ending a phone call:

- ğŸ“ Person A: â€œOkay, I'm done talking.â€ (`FIN`)
- ğŸ“ Person B: â€œGot it, me too.â€ (`FIN`)
- ğŸ“ Person A: â€œCool, bye!â€ (`ACK`)

## âœ… Summary Table

| **Step**               | **Flag(s)**       | **Meaning**                            |
|------------------------|-------------------|----------------------------------------|
| Connection Start #1    | SYN               | Client says: â€œLetâ€™s start talking.â€    |
| Connection Start #2    | SYN + ACK         | Server says: â€œSure, I hear you!â€       |
| Connection Start #3    | ACK               | Client: â€œGreat, letâ€™s talk.â€           |
| Data Transfer          | ---               | Actual data flows (e.g., web pages)    |
| Connection End #1      | FIN + ACK         | One side says: â€œIâ€™m done.â€             |
| Connection End #2      | FIN + ACK         | Other side says: â€œIâ€™m also done.â€      |
| Connection End #3      | ACK               | Final acknowledgment and goodbye       |

---
# ğŸ“¶ **Networking Primer â€“ Layers 5 to 7 (Application Layer Overview)**

In networking, the **lower layers** (like Layers 1-4) handle the **physical transmission**, routing, and delivery of data packets. However, the **upper layers**, specifically **Layers 5-7**, focus on **end-user applications**, **data formatting**, **encryption**, and **session management**. These layers ensure that **data is presented properly to users** and that **communication between applications is reliable and secure**.


## ğŸŒ **HTTP (Hypertext Transfer Protocol)**

- **Layer**: Application Layer (Layer 7)
- **Port**: TCP port 80 (or 8000 by default)
- **Purpose**: Transfers hypertext/media between client and server in plaintext.
- **State**: Stateless â€“ each request is independent.

**How it works**:  
The client (browser) sends an HTTP request to the server for a resource like an HTML page, image, or video. The server responds with the requested content over a **TCP connection**.

### ğŸ”„ Common HTTP Methods:
| Method   | Description |
|----------|-------------|
| **HEAD** | Same as GET but without the body; used to check resource availability or server info. |
| **GET**  | Requests data from the server. Example: `GET http://example.com/index.html`. |
| **POST** | Sends data to the server (e.g., form submissions, login details). |
| **PUT**  | Uploads/replaces a resource at a specific URI. |
| **DELETE** | Deletes the specified resource on the server. |
| **OPTIONS** | Queries the server for supported methods and features. |
| **TRACE** | Echoes back the received request for testing/debugging. |
| **CONNECT** | Tunnels traffic through a proxy (commonly used with HTTPS). |

ğŸ“Œ **Note**: Only **GET** and **HEAD** are required by HTTP standards. Others are optional and depend on server configuration.

ğŸ”— **Reference**: [RFC 2616](https://datatracker.ietf.org/doc/html/rfc2616)
## ğŸ” **HTTPS (HTTP Secure)**

- **Layer**: Application Layer (Layer 7)
- **Port**: TCP port 443 (or 8443)
- **Purpose**: Encrypts HTTP communication using **TLS/SSL**.
- **Security**: Protects against eavesdropping, MITM (Man-in-the-Middle) attacks.

### ğŸ’¡ How HTTPS works:
HTTPS uses **TLS (Transport Layer Security)** to encrypt HTTP messages. The process begins with a **TLS handshake**, which includes:

1. **ClientHello**: Client proposes TLS version, cipher suites, and random value.
2. **ServerHello**: Server responds with chosen cipher and its certificate.
3. **Key Exchange**: Client and server derive a **shared secret** (the master key).
4. **Authentication**: Using X.509 certificates.
5. **Secure Communication**: Encrypted data transfer begins via the established secure channel.

ğŸ”— **Reference**: [RFC 2246](https://datatracker.ietf.org/doc/html/rfc2246)

## ğŸ“ **FTP (File Transfer Protocol)**

- **Layer**: Application Layer (Layer 7)
- **Ports**: TCP port **21** (commands) and **20** (data transfer)
- **Purpose**: Transfer files between client and server.
- **Security**: Unsecured by default; passwords sent in plaintext.

**Modes of Operation**:
1. **Active Mode**: Server connects back to the client using port 20 after receiving PORT command.
2. **Passive Mode (PASV)**: Client initiates both control and data connections (commonly used behind NAT/firewalls).

### ğŸ’¬ Common FTP Commands:
| Command | Description |
|---------|-------------|
| `USER`  | Username for authentication. |
| `PASS`  | Password for authentication. |
| `PORT`  | Sets up data connection in active mode. |
| `PASV`  | Requests passive mode from server. |
| `LIST`  | Lists files in the current directory. |
| `CWD`   | Changes working directory. |
| `PWD`   | Displays current directory path. |
| `SIZE`  | Returns file size. |
| `RETR`  | Downloads a file. |
| `QUIT`  | Ends the FTP session. |

ğŸ“Œ Most modern systems prefer **SFTP (Secure FTP)** or **FTPS** due to the security concerns with FTP.

ğŸ”— **Reference**: [RFC 959](https://datatracker.ietf.org/doc/html/rfc959)

## ğŸ–¥ï¸ **SMB (Server Message Block)**

- **Layer**: Application Layer (Layer 7)
- **Port**: TCP port 445 (modern), also NetBIOS ports 137-139 (legacy)
- **Purpose**: File and resource sharing (printers, files, authentication) primarily in Windows environments.
- **Security**: Requires authentication; supports signing and encryption in newer versions.

**How it works**:
- SMB establishes sessions using TCP (3-way handshake).
- Then, clients can authenticate and access shared resources like folders or printers.
- Uses **NTLM** or **Kerberos** for authentication.

### âš ï¸ Security Considerations:
- SMB is often targeted by attackers for **lateral movement** and **credential theft**.
- Monitoring SMB traffic (especially failed logins or unusual file access) is critical in network defense.

## âœ… Summary

| Protocol | Purpose | Port(s) | Secure Version |
|----------|---------|--------|----------------|
| HTTP     | Web browsing / data transfer | 80 / 8000 | HTTPS |
| HTTPS    | Encrypted web browsing | 443 / 8443 | Yes (TLS/SSL) |
| FTP      | File transfers | 20 (data), 21 (commands) | SFTP / FTPS |
| SMB      | File/printer/resource sharing | 445 | Yes (modern SMBv3+) |

---

Sure! Here's a clear and easy-to-understand **explanation** of the text you provided about **Network Traffic Analysis (NTA)**:

---

# ğŸ” **The Analysis Process**

**Network Traffic Analysis** is the process of carefully studying the data moving through a network. This data includes all the communications between computers, servers, and other devices. The goal is to understand whatâ€™s happening, detect anything unusual, and respond to potential threats or problems quickly.

## ğŸ” **Why Is It a Process?**

NTA is not a one-size-fits-all process. It depends on:
- The **tools** you have (like Wireshark, Splunk, ELK Stack, etc.).
- The **permissions** given by your organization (e.g., access to logs or internal devices).
- How much **visibility** you have into the network (can you see just one system, or the whole environment?).

Even though these things may change, the goal is to create a **repeatable, reliable process** for analyzing traffic each time.
## ğŸ§  **What Does Analysis Involve?**

When doing traffic analysis, you:
1. **Break down data into understandable parts** (like protocols, ports, IPs).
2. **Look for anything strange**, such as:
   - Unusual traffic patterns.
   - Connections from unknown or external IPs.
   - Unauthorized access (e.g., using RDP, SSH, or Telnet).
   - Spikes in traffic before a crash or system slowdown.

3. **Compare with a baseline** â€” the usual, healthy traffic behavior in your network. This helps you detect when somethingâ€™s off.

## ğŸ›¡ï¸ **Why Is It Important for Defense?**

Without NTA, youâ€™re basically **flying blind**. You wouldnâ€™t know:
- Which devices are talking the most (top talkers).
- Whether internal systems are communicating normally.
- If an attack is happening right now or already happened.

Traffic visibility lets you:
- Spot threats **before** they cause damage.
- **Fix problems fast**.
- Understand your network deeply.

## âš™ï¸ **Using Other Tools with NTA**

NTA gets even stronger when used with other tools, like:
- **IDS/IPS** (Intrusion Detection/Prevention Systems).
- **Firewalls**.
- **System logs** (from hosts or network devices).
- **SIEMs** like **Splunk** or **ELK Stack**.

These tools can alert you to known threats, based on **signatures** of known attacks or suspicious behavior.

## âš ï¸ **What About Day-to-Day Operations?**

NTA is not only for detecting attacks. It also helps with:
- **Troubleshooting** (e.g., why canâ€™t this machine connect?).
- **Monitoring protocol behavior** (e.g., is DNS working correctly?).
- **Diagnosing performance issues** (e.g., high latency or packet loss).

If you can see the traffic, you can **see where things go wrong**.

## ğŸ‘ï¸ **Donâ€™t Rely Only on Automation**

Tools are helpful, but theyâ€™re not perfect. Attackers are constantly learning how to bypass automated systems.

Thatâ€™s why:
- You should **use tools**, but also
- **Check things manually**, using your own eyes and judgment.

The **human analyst** is still the most powerful tool in cybersecurity.

## âœ… **Summary**

- NTA helps us understand what's happening on the network.
- It helps identify both security threats and operational issues.
- It works best when combined with other tools and human analysis.
- Donâ€™t rely only on automation â€” your skills and eyes are key to catching sophisticated threats.

---

# ğŸ§  **Understanding Analysis Dependencies**

Traffic analysis can be done in **two main ways**: **Passive** and **Active**.  
Each method has its own **requirements (or dependencies)** depending on how traffic is captured and analyzed.

### ğŸ”¹ **Passive Traffic Capture**
- You're **listening** to traffic without interfering.
- You **copy** data that is already flowing.
- No change to the network is needed.
- Often uses **mirrored ports** or **wireless sniffing** to see data.

### ğŸ”¹ **Active Traffic Capture**
- You place your tool **in-line**, like a checkpoint on a highway.
- You **intercept** traffic as it flows between devices.
- Requires **topology changes** (e.g., adding a tap or device in the network path).
- Provides more **real-time insight**, but more complex and risky.

## ğŸ“‹ **Table of Traffic Capture Dependencies**

| Dependency | Passive | Active | Explanation |
|------------|---------|--------|-------------|
| **Permission** | âœ… | âœ… | No matter which method, you must always get **written permission** from someone with authority. This is especially important in **sensitive industries** like healthcare or finance, where unauthorized traffic capture can be **illegal**. |
| **Mirrored Port** | âœ… | âŒ | Needed for passive mode. A **mirrored port** copies traffic from one port to another so your capture tool can read it. In wireless, you must connect to the **correct SSID** to see meaningful traffic. |
| **Capture Tools** | âœ… | âœ… | Tools like **Wireshark, TCPDump** help collect and analyze traffic. Be aware that **PCAP files grow fast** and may slow down your machine when filtered repeatedly. |
| **In-line Placement** | âŒ | âœ… | Required for active mode. You **insert** your tool into the path of network traffic like a "middle hop", so packets flow through it. Devices wonâ€™t notice it, but the network topology does. |
| **Network Tap or Dual NICs** | âŒ | âœ… | A **network tap** or a machine with **two NICs (network cards)** is needed to forward traffic while capturing. Best used on a **Layer 3 link** between network segments. |
| **Storage & Processing Power** | âœ… | âœ… | Both methods need **adequate disk space and CPU power**. Active mode may handle much more data, like trying to catch water from a firehose versus a sink faucet (passive). |

## ğŸ§­ **Why a Traffic Baseline Matters**

Even though not a strict "dependency", knowing what **normal traffic** looks like helps **speed up and improve analysis**.

Without a baseline, you have to:
- Inspect **every connection**
- Guess whatâ€™s normal vs suspicious
- Spend **hours filtering out noise**

With a baseline, you can:
- Instantly **ignore known-good** communication
- Focus only on **anomalies**
- React **faster** to threats

## ğŸ§ª **Real-World Example**

Youâ€™re a network admin at a big company. Suddenly:
- Some users report **slow networks**
- Strange **files appear** on desktops

You:
1. Connect to the affected network segment.
2. Start capturing traffic.
3. Stop after a few minutes and begin analyzing.

**Without a baseline:**
- Youâ€™re overwhelmed by the volume of data.
- You have to **check every single host and port** manually.
- You donâ€™t know whatâ€™s normal for this segment.

**With a baseline:**
- You quickly **filter out regular traffic**.
- You notice:
  - **Unusual traffic on ports 445 and 8080** between **user PCs**.
  - Normally, these ports are used between a user and a **server**, not peer-to-peer.
- This is suspicious and could mean **malware** or **lateral movement**.

Now, you can open a **trouble ticket** or escalate the incident **faster**, possibly preventing more damage.

## âš¡ Final Thoughts

- **Faster visibility = Less damage**
- Understand your **network flow** and **protocol behavior**
- Choose the **right capture method** based on your environment
- Build a **baseline** to detect threats faster and more accurately



## ğŸŒ **Network Traffic Analysis (NTA)**

### ğŸ§  **What Is It?**  
**Network Traffic Analysis** is the process of **monitoring, collecting, and analyzing** traffic flowing through your network to:
- Detect threats ğŸ›¡ï¸  
- Identify anomalies ğŸ”  
- Understand normal behavior ğŸ“Š  
- Investigate incidents ğŸ”¦  

### ğŸ¯ **Main Purposes of NTA**  

1. **ğŸ‘ï¸ Monitor Network in Real-Time**  
   - Watch how systems communicate  
   - Detect signs of malicious activity as it happens

2. **ğŸ“ Set Baselines**  
   - Learn what "normal" looks like  
   - Helps spot unusual or suspicious behavior quickly

3. **ğŸš© Spot Anomalies and Misconfigurations**  
   - Suspicious IPs ğŸ•µï¸â€â™‚ï¸  
   - Unusual ports and protocols (e.g., HTTP errors, TCP issues)  
   - Misconfigured or unauthorized network services

4. **ğŸ§¬ Detect Malware "On the Wire"**  
   - Catch ransomware, exploits, and backdoor tools by observing communication patterns

5. **ğŸ”™ Support Threat Hunting & Incident Response**  
   - Analyze historical data to investigate attacks  
   - Trace the attack path or lateral movement

### ğŸ’£ **Why It Matters?**  
Attackers **must communicate** with your network to:
- Deliver payloads ğŸ¯  
- Move laterally â†”ï¸  
- Exfiltrate data ğŸ“¤

By analyzing traffic, you can **spot**:
- ğŸ‘¾ Port scanning (e.g., many SYN packets on unused ports)  
- ğŸ§ª Exploits or suspicious traffic  
- ğŸ§â€â™‚ï¸ Internal abuse or privilege misuse  
- ğŸ•³ï¸ Backdoors left open for command & control

### âš™ï¸ **Typical NTA Workflow**  

1. ğŸ“¡ **Collect** network traffic (e.g., via SPAN port, TAPs, or agents)  
2. ğŸ§  **Analyze** data using tools like Wireshark, Zeek, Suricata, or commercial NDR systems  
3. âš ï¸ **Alert** on known threats or anomalies  
4. ğŸ” **Investigate** and respond if malicious behavior is detected

### âœ… **Key Skills Needed**  
- Understand common protocols (HTTP, DNS, SMB, etc.)  
- Know normal traffic patterns in your network  
- Interpret packet data and identify red flags  
- Use packet analysis tools efficiently

---

## ğŸ› ï¸ **Required Skills & Knowledge for NTA**

> ğŸ”‘ *You donâ€™t need to memorize everythingâ€”just know what to look for and where.*  
> These skills are essential not just for NTA, but for cybersecurity as a whole.

### ğŸŒ 1. **TCP/IP Stack & OSI Model**
ğŸ“¦ Understand how data travels from application to network and back.  
ğŸ§© Helps connect how apps â†”ï¸ networks work together.

- **OSI Model (7 layers)** = ğŸ“¡ Physical â†’ ğŸ’¾ Application  
- **TCP/IP Model (4 layers)** = ğŸŒ Network Interface â†’ ğŸ“¬ Application

> ğŸ§  *Helps interpret where an issue occurs and what layer to investigate.*

### ğŸ›œ 2. **Basic Network Concepts**
ğŸ”„ Switching vs Routing  
ğŸ¢ Office traffic â‰  Backbone traffic

- Switch = Local traffic â†”ï¸  
- Router = Internet/Network gateways ğŸŒ

> ğŸ“ *Know where youâ€™re tapping into the networkâ€”context matters!*

### ğŸ“Š 3. **Common Ports & Protocols**
ğŸ¯ Recognize standard ports like:
- 80 (HTTP) ğŸŒ  
- 443 (HTTPS) ğŸ”  
- 53 (DNS) ğŸ”  
- 445 (SMB) ğŸ“  

> ğŸ§  *Quick ID of protocols helps detect suspicious or unexpected behavior.*

### ğŸ“¦ 4. **IP Packets & Sublayers**
ğŸ§© Know how TCP & UDP differ:

- **TCP** = Reliable, ordered, connection-based ğŸ”  
  â†’ Great for tracking conversations between hosts  
- **UDP** = Fast, connectionless, no guarantee ğŸš€  
  â†’ Harder to reconstruct full sessions

> ğŸ” *Understand packet structure = better detection of weird or malformed data.*

### ğŸ” 5. **Protocol Transport Encapsulation**
ğŸ§± Each layer wraps the data of the previous (like nesting dolls ğŸª†):

- Ethernet (frame) â†’ IP (packet) â†’ TCP (segment) â†’ App Data

> ğŸ§  *Spotting when headers change can reveal tunneling, misbehavior, or attacks.*

### ğŸ“ Final Tip:
You donâ€™t need to **master** everything at once â€” but building **familiarity** with these areas will level up your network threat detection skills significantly.


### ğŸŒ **Environment and Equipment for Network Traffic Analysis**

To perform **Network Traffic Analysis (NTA)** effectively, there are various tools and equipment that help capture, inspect, and analyze network traffic. Each tool serves a different purpose â€” some are designed to **capture live traffic**, others to **analyze saved data**, and some can even **reassemble streams or visualize large datasets**.

> âš ï¸ **Note**: These tools are not just for administrators. Attackers can also misuse them for malicious purposes.

### ğŸ§° **Common Traffic Analysis Tools**

| ğŸ› ï¸ **Tool** | ğŸ” **Description** |
|-------------|--------------------|
| **tcpdump** | A command-line tool that captures and interprets network traffic using **LibPcap**. Lightweight and commonly used on Linux. |
| **TShark** | The command-line version of Wireshark. It can capture live traffic or read from a file and **decode packets**. Similar to tcpdump but more detailed. |
| **Wireshark** | A powerful **graphical network traffic analyzer**. It decodes packets and displays detailed protocol information using multiple dissectors. |
| **NGrep** | Works like the `grep` command but for network traffic. Supports **regular expressions** and **BPF syntax** to find patterns in HTTP, FTP, and other protocols. |
| **tcpick** | A command-line sniffer specialized in **tracking and reassembling TCP streams**. It can reconstruct files from TCP connections. |
| **Network Taps** | Hardware devices (e.g., Gigamon, Niagara Taps) that **copy network traffic** and send it elsewhere for analysis. Can be inline or passive. |
| **SPAN Ports** | A feature on switches/routers that **mirrors traffic** to a specific port for monitoring or logging purposes. Often used to collect traffic for external analysis. |
| **Elastic Stack** | A collection of tools (Elasticsearch, Logstash, Kibana) that **ingests, stores, and visualizes** large amounts of data, including network logs. |
| **SIEMs (e.g., Splunk)** | Central platforms for **analyzing, visualizing, alerting**, and performing **forensic investigations** based on network and system data. |


## ğŸ§ª **Performing Network Traffic Analysis (NTA)**

### ğŸ“¡ **What is it?**
Performing NTA can be as simple as watching live network traffic scroll through your terminal, or as complex as capturing traffic using a network tap and analyzing it through tools like a **SIEM** (Security Information and Event Management).

### âš™ï¸ **Basic Requirements**
To **passively capture traffic**, you must be:
- ğŸ“ **Connected to the right network segment** (especially important in switched networks using VLANs).
- ğŸ§· Use tools like **network taps**, **SPAN ports**, or **port mirroring** to get copies of traffic across network links â€” even if your capture device isnâ€™t the final destination.

### ğŸ”„ **NTA Workflow (Step-by-Step)**

Although Network Traffic Analysis is not always a straightforward or linear process, hereâ€™s a typical workflow to follow:

![alt text](image-32.png)

### **1. Ingest Traffic** ğŸ§²  
Start by **capturing the traffic** on your target network segment.  
- Use **filters** (like BPF filters in Wireshark or tcpdump) if you're looking for something specific (e.g., traffic on a certain port or from a certain host).

### **2. Reduce Noise by Filtering** ğŸ”‡  
Network traffic can be very **noisy**, especially in large or production environments.  
- Filter out unnecessary data like **broadcast** or **multicast** packets to focus on what matters.
- This step makes the analysis more efficient and readable.

### **3. Analyze and Explore** ğŸ”  
Now start digging into the **relevant data**. Ask questions like:
- ğŸŸ¡ **Is the traffic encrypted or plaintext?** (e.g., HTTP vs HTTPS)
- ğŸŸ  **Are users accessing resources they shouldnâ€™t?**
- ğŸ”µ **Are unusual host-to-host communications happening?**
- âš ï¸ **Check protocol flags** (like TCP SYN, ACK) to detect scans or unusual behavior.

### **4. Detect and Alert** ğŸš¨  
- â— Look for **errors or communication failures** (e.g., a server not responding).
- ğŸ›‘ Decide if the traffic is **normal or suspicious/malicious**.
- ğŸ” Use tools like **IDS/IPS** (e.g., Snort, Suricata) to automatically inspect traffic for known signatures and anomalies.

### **5. Fix and Monitor** ğŸ”§ğŸ‘€  
- After resolving a detected issue (e.g., patching a system, blocking a port), you must **keep monitoring** the affected area to confirm:
  - âœ… The problem is truly fixed
  - ğŸš« No further abnormal behavior occurs

---

#  Networking Primer - Layers 1-4


### ğŸ“ **Purpose of This Section**
This section is a **quick refresher** to help you understand the **basic networking concepts** you'll encounter when analyzing network traffic. Without understanding protocols, ports, and packet structures, it's impossible to properly interpret what you capture in tools like Wireshark or tcpdump.


## ğŸ§± **OSI vs. TCP/IP Models**

![alt text](image-33.png)

### ğŸ§© **What Are They?**

These models describe how **data travels** from one computer to another across a network. They're **frameworks** that break down communication into **layers**, each handling a specific part of the process.

### ğŸ” **Comparison Table**

| Trait         | OSI Model                    | TCP/IP Model                     |
|--------------|------------------------------|----------------------------------|
| **Layers**    | 7 Layers                     | 4 Layers                         |
| **Flexibility** | Strict structure             | More flexible                    |
| **Design**     | Protocol-independent, conceptual | Built from real-world protocols |

### ğŸ—‚ï¸ **Layer Mapping**

- **OSI Layers (7):**  
  1. Physical  
  2. Data Link  
  3. Network  
  4. Transport  
  5. Session  
  6. Presentation  
  7. Application  

- **TCP/IP Layers (4):**  
  1. Link  
  2. Internet  
  3. Transport  
  4. Application

> ğŸ§  Think of the **OSI model** as a **theoretical model** (used for understanding concepts), while the **TCP/IP model** is more **practical**, based on how real networks function.

## ğŸ“¦ **What Is a PDU (Protocol Data Unit)?**

A **PDU** is a **packet of data** that includes:
- **Control information** (headers, flags, etc.)
- **Encapsulated data** from higher layers

Each layer of the model **adds its own header** to the packet as it moves **down the stack**. This process is called **encapsulation**.

### ğŸ§Š **Encapsulation Example**
![alt text](image-34.png)
- At the **Application Layer**, your message might just be: "GET /index.html"
- At the **Transport Layer**, it adds a **TCP header** with source and destination **ports**
- At the **Network Layer**, it adds an **IP header** with source/destination **IP addresses**
- At the **Link Layer**, it adds **MAC addresses** and maybe **frame checksums**

Each layer **wraps** the previous data like layers of an onion.
### ğŸ§ª **Viewing PDUs in Wireshark**
![alt text](image-35.png)
In Wireshark:
- PDUs are shown **in reverse** order â€” because youâ€™re viewing how the data is **unwrapped** during analysis.
- Youâ€™ll see:  
  Ethernet â IP â TCP â HTTP â Payload

This unwrapping is called **decapsulation**.
### âœ… **Why This Is Important**
Understanding the structure of PDUs and how protocols work helps you:
- Recognize malicious behavior or anomalies in captured traffic
- Interpret logs and alerts more accurately
- Debug network issues more efficiently

Here's a **clear explanation in English** of the "Addressing Mechanisms" section, focusing on **MAC addressing** and how it works in a network:

---

## ğŸ“¬ **Addressing Mechanisms in Networking**

To ensure data reaches the correct device on a network, we use **addressing mechanisms**. These are identifiers used to deliver data across different network layers. One of the most foundational mechanisms is the **MAC address**.

### ğŸ§¾ **What Is a MAC Address?**

A **MAC (Media Access Control) address** is a **unique identifier** assigned to a network interface (like a network card or Wi-Fi adapter). It is:

- **48 bits long**
- Usually displayed as **6 groups** of **2 hexadecimal digits**, like:  
  `00:1A:2B:3C:4D:5E`
- Set by the **manufacturer** of the device (also known as a **burned-in address**)

### ğŸŒ **Where Is the MAC Address Used?**

- The MAC address operates at **Layer 2** of the OSI model (the **Data Link Layer**)
- It's used for **host-to-host communication** **within the same local network** (also known as a **broadcast domain**)
- Devices use MAC addresses to **send frames** to each other within a LAN

### ğŸ“¦ **MAC Address in Action**

Letâ€™s walk through an example:

1. **Your computer** wants to send data to another device on the same network.
2. It uses the **MAC address** of that destination device to send the frame.
3. If the destination is **outside the local network**, it sends the data to the **default gateway** (usually a router).
4. The router:
   - Strips off the original Layer 2 information.
   - Adds **new MAC address information** for the **next hop**.
   - Forwards the data based on **IP addresses** at Layer 3.

> ğŸ§  In short, MAC addresses are used **within the same network**, while IP addresses are used to **navigate between networks**.

### ğŸ” **How MAC Addresses Help in Routing**

When a packet needs to leave the local network:
- The device sends it to the router using the **routerâ€™s MAC address**.
- The router then:
  - Reads the **Layer 3 (IP)** destination address,
  - Decides where to send it,
  - **Replaces** the Layer 2 MAC address with the one for the **next destination**.

This process continues until the packet reaches its final destination.

### âœ… **Why This Is Important**

Understanding MAC addressing is essential for:
- **Troubleshooting** network issues (e.g., ARP problems, duplicate MACs)
- **Network security** (e.g., MAC filtering, identifying spoofed addresses)
- **Traffic analysis** (MAC addresses are visible in packet captures)

--- 
Hereâ€™s a **clear explanation in English** of the "IP Addressing" section, broken down for easy understanding:

---

## ğŸŒ **IP Addressing**

To send data across different networks (not just within a local network), we need a global system to identify devices. Thatâ€™s where **IP (Internet Protocol)** comes in. It helps **route data between networks** by using **IP addresses**.

### ğŸ“¡ **What Is IP?**

- IP is a **connectionless protocol** that:
  - Routes packets from source to destination across networks.
  - Splits and reassembles large data into smaller chunks (datagrams).
  - Works with other protocols like **TCP** to guarantee delivery (since IP itself doesnâ€™t).
- Operates at:
  - **Layer 3 (Network)** of the OSI model.
  - **Internet layer** of the TCP/IP model.

### ğŸ”¢ **IPv4 (Internet Protocol version 4)**

![alt text](image-36.png)

- **Most commonly used version** of IP today.
- Address length: **32-bit** â†’ shown as **four numbers (octets)** separated by dots (e.g., `192.168.1.1`)
- Each number ranges from **0 to 255**.
- Example: `192.168.86.243`
- IPv4 is essential for **routing data across different networks**.

### âš ï¸ **Why IPv4 Isnâ€™t Enough Anymore**

- IPv4 allows for **about 4.3 billion unique addresses**, which seemed a lotâ€”but we ran out quickly due to:
  - Growth of the internet.
  - Reserved/private address spaces.
  - Devices needing unique addresses.
- **Solutions attempted:**
  - **VLSM (Variable Length Subnet Masking)** and **CIDR (Classless Inter-Domain Routing)** to use addresses more efficiently.
  - But even those werenâ€™t enough.

### ğŸ§® **IPv6 (Internet Protocol version 6)**

- Created to **replace IPv4** and solve the address exhaustion problem.
- Address length: **128-bit** â†’ shown as **eight groups of four hexadecimal digits** (e.g., `2001:0db8:85a3:0000:0000:8a2e:0370:7334`)
- Can support **~340 undecillion addresses** â€” enough for every grain of sand on Earth to have its own IP!

### ğŸš€ **Benefits of IPv6**

- **Larger address space** for future growth.
- **Built-in security features** like **IPSec**.
- **Simplified packet headers** make processing faster.
- **Supports multicasting** better than IPv4.
- **Each device can have a global address**â€”no need for NAT (Network Address Translation).

### ğŸ“¬ **IPv6 Address Types**

| **Type**   | **Description**                                                                 |
|------------|----------------------------------------------------------------------------------|
| **Unicast**   | One-to-one: sent from one device to one specific device.                        |
| **Anycast**   | One-to-many (but only one responds): good for **load balancing**.               |
| **Multicast** | One-to-many: all devices in the group receive the same packet.                 |
| **Broadcast** | Doesnâ€™t exist in IPv6 (unlike IPv4); replaced by multicast instead.            |

### ğŸ“‰ **Adoption of IPv6**

- Even though IPv6 is technically superior, adoption has been **slow**.
- As of now, only about **40% of internet traffic globally** uses IPv6 (according to Google).

### âœ… **Quick Summary**

| **Feature**      | **IPv4**                          | **IPv6**                                 |
|------------------|-----------------------------------|------------------------------------------|
| Address Length   | 32-bit                            | 128-bit                                  |
| Format           | Decimal (e.g., 192.168.1.1)       | Hexadecimal (e.g., 2001:db8::1)          |
| Total Addresses  | ~4.3 billion                      | ~340 undecillion                        |
| Broadcast        | Yes                               | No (uses multicast instead)              |
| Built-in Security| No                                | Yes (via IPSec)                          |
| Adoption Rate    | Still dominant                    | Growing (~40% globally)                  |

---
## ğŸš¦ **TCP / UDP, Transport Mechanisms**

The **Transport Layer** is like the **traffic controller** of your dataâ€”it decides **how** the data moves between devices and makes sure it gets to the right place in the right order (or not, depending on the protocol used).

There are **two main transport protocols**:
1. **TCP (Transmission Control Protocol)** â€“ reliable, slower
2. **UDP (User Datagram Protocol)** â€“ fast, but unreliable

### ğŸ” **TCP â€“ Reliable and Connection-Oriented**

- **Connection-based:** TCP sets up a connection using a **three-way handshake** (like saying: â€œHello? You there? Yes? Okay, let's talk!â€).
- **Reliable:** Every packet sent is **acknowledged**. If a packet is lost, TCP will **retransmit** it.
- **Ordered:** Packets are **numbered** so they can be reassembled in the correct order.
- **Slower**, but **safer**â€”great when **data accuracy matters**.

#### âœ… Example use cases:
- **SSH (Secure Shell):** You wouldnâ€™t want to lose parts of a command like `sudo passwd user`!
- **Web browsing (HTTP/HTTPS):** You want to see the full webpage, not pieces missing.

### ğŸš€ **UDP â€“ Fast and Connectionless**

- **Connectionless:** No handshake. Just sends the packet and forgetsâ€”**"fire and forget"** style.
- **No acknowledgments or retransmissions**â€”UDP doesn't care if the packet got there or not.
- **Much faster**, but with **no guarantee** it got delivered or in order.
  
#### âš¡ Example use cases:
- **Video streaming (e.g., YouTube):** Itâ€™s okay if a few pixels dropâ€”you want smooth playback, not perfect frames.
- **DNS (Domain Name System):** A fast queryâ€”if it fails, just ask again.

### ğŸ§  **Quick Comparison: TCP vs UDP**

| **Feature**                | **TCP**                              | **UDP**                             |
|---------------------------|---------------------------------------|-------------------------------------|
| **Connection**            | Connection-oriented (3-way handshake) | Connectionless                      |
| **Reliability**           | Reliable (acknowledges packets)       | Unreliable (no acknowledgment)      |
| **Speed**                 | Slower (more overhead)                | Faster (less overhead)              |
| **Use Case**              | SSH, HTTP, file transfers             | Streaming, gaming, DNS              |
| **Error Handling**        | Yes                                   | No                                  |
| **Packet Order**          | Maintains order                       | May arrive out of order or not at all |

### ğŸ¯ When to Use What?

- **Use TCP** when:
  - You **need all the data**, intact and in order.
  - Examples: **Web, remote login, email, file transfers**.

- **Use UDP** when:
  - You **donâ€™t need perfect delivery**, just **speed**.
  - Examples: **Video calls, live streams, online gaming, DNS**.

### ğŸ§© Real-World Analogy

| TCP                              | UDP                              |
|----------------------------------|----------------------------------|
| Like sending a **registered letter** (signature needed) | Like tossing a **postcard** in the mail |
| Slower, but you know it got there | Fast, but no guarantee            |
---
## ğŸ” **TCP Three-Way Handshake** â€“ *How a Connection is Established*

Think of this like **starting a polite conversation** between two people (a client and a server). You donâ€™t just start talkingâ€”you say hello first, they respond, then you both agree to talk. In networking, this is how TCP ensures a **reliable connection** is made before sending data.

### ğŸ“¦ **Step-by-step: How the 3-Way Handshake Works**

1. **Client â¡ï¸ Server: SYN (Synchronize)**
   - The **client** wants to start a session, so it sends a packet with the `SYN` flag.
   - It includes a **sequence number** (like a label for the conversation).
   - Also negotiates things like window size and maximum segment size (how much data can be sent at once).

2. **Server â¡ï¸ Client: SYN-ACK (Synchronize + Acknowledge)**
   - The **server** receives the SYN, agrees to start the session.
   - It sends back a **SYN** (for its own sequence number) and an **ACK** (to acknowledge the clientâ€™s SYN).

3. **Client â¡ï¸ Server: ACK (Acknowledge)**
   - The **client** acknowledges the serverâ€™s response.
   - Now the session is established, and both sides can start sending actual data!

### ğŸ’¡ Real-World Analogy

![alt text](image-37.png)

Imagine two people trying to start a phone call:

- ğŸ“ **Person A (Client)**: "Hey, can we talk?" (`SYN`)
- ğŸ“ **Person B (Server)**: "Sure, I hear you. Let's talk!" (`SYN-ACK`)
- ğŸ“ **Person A**: "Cool, we're connected!" (`ACK`)

Now they can talk normally (exchange data).

### ğŸŒ Example in Networking

- Port `57678`: Random high port on client
- Port `80`: HTTP port on the server
- Packets:
  - Line 1: Client â†’ Server (`SYN`)
  - Line 2: Server â†’ Client (`SYN-ACK`)
  - Line 3: Client â†’ Server (`ACK`)
  - Line 4: Real data starts flowing (e.g., an HTTP request for a web page)

## ğŸ“´ **TCP Session Teardown** â€“ *How a Connection is Gracefully Closed*

Just like you **donâ€™t hang up the phone without saying goodbye**, TCP also politely ends conversations using the **FIN** (Finish) and **ACK** flags.

![alt text](image-38.png)
### ğŸ”š **Steps for Closing a TCP Connection**

1. **FIN, ACK** â€“ One side says, â€œIâ€™m done sending data.â€
2. **FIN, ACK** â€“ The other side replies, â€œGot it, and Iâ€™m done too.â€
3. **ACK** â€“ Final acknowledgment. The session is now closed.

### ğŸ’¡ Analogy for Teardown

Like ending a phone call:

- ğŸ“ Person A: â€œOkay, I'm done talking.â€ (`FIN`)
- ğŸ“ Person B: â€œGot it, me too.â€ (`FIN`)
- ğŸ“ Person A: â€œCool, bye!â€ (`ACK`)

## âœ… Summary Table

| **Step**               | **Flag(s)**       | **Meaning**                            |
|------------------------|-------------------|----------------------------------------|
| Connection Start #1    | SYN               | Client says: â€œLetâ€™s start talking.â€    |
| Connection Start #2    | SYN + ACK         | Server says: â€œSure, I hear you!â€       |
| Connection Start #3    | ACK               | Client: â€œGreat, letâ€™s talk.â€           |
| Data Transfer          | ---               | Actual data flows (e.g., web pages)    |
| Connection End #1      | FIN + ACK         | One side says: â€œIâ€™m done.â€             |
| Connection End #2      | FIN + ACK         | Other side says: â€œIâ€™m also done.â€      |
| Connection End #3      | ACK               | Final acknowledgment and goodbye       |

---
# ğŸ“¶ **Networking Primer â€“ Layers 5 to 7 (Application Layer Overview)**

In networking, the **lower layers** (like Layers 1-4) handle the **physical transmission**, routing, and delivery of data packets. However, the **upper layers**, specifically **Layers 5-7**, focus on **end-user applications**, **data formatting**, **encryption**, and **session management**. These layers ensure that **data is presented properly to users** and that **communication between applications is reliable and secure**.


## ğŸŒ **HTTP (Hypertext Transfer Protocol)**

- **Layer**: Application Layer (Layer 7)
- **Port**: TCP port 80 (or 8000 by default)
- **Purpose**: Transfers hypertext/media between client and server in plaintext.
- **State**: Stateless â€“ each request is independent.

**How it works**:  
The client (browser) sends an HTTP request to the server for a resource like an HTML page, image, or video. The server responds with the requested content over a **TCP connection**.

### ğŸ”„ Common HTTP Methods:
| Method   | Description |
|----------|-------------|
| **HEAD** | Same as GET but without the body; used to check resource availability or server info. |
| **GET**  | Requests data from the server. Example: `GET http://example.com/index.html`. |
| **POST** | Sends data to the server (e.g., form submissions, login details). |
| **PUT**  | Uploads/replaces a resource at a specific URI. |
| **DELETE** | Deletes the specified resource on the server. |
| **OPTIONS** | Queries the server for supported methods and features. |
| **TRACE** | Echoes back the received request for testing/debugging. |
| **CONNECT** | Tunnels traffic through a proxy (commonly used with HTTPS). |

ğŸ“Œ **Note**: Only **GET** and **HEAD** are required by HTTP standards. Others are optional and depend on server configuration.

ğŸ”— **Reference**: [RFC 2616](https://datatracker.ietf.org/doc/html/rfc2616)
## ğŸ” **HTTPS (HTTP Secure)**

- **Layer**: Application Layer (Layer 7)
- **Port**: TCP port 443 (or 8443)
- **Purpose**: Encrypts HTTP communication using **TLS/SSL**.
- **Security**: Protects against eavesdropping, MITM (Man-in-the-Middle) attacks.

### ğŸ’¡ How HTTPS works:
HTTPS uses **TLS (Transport Layer Security)** to encrypt HTTP messages. The process begins with a **TLS handshake**, which includes:

1. **ClientHello**: Client proposes TLS version, cipher suites, and random value.
2. **ServerHello**: Server responds with chosen cipher and its certificate.
3. **Key Exchange**: Client and server derive a **shared secret** (the master key).
4. **Authentication**: Using X.509 certificates.
5. **Secure Communication**: Encrypted data transfer begins via the established secure channel.

ğŸ”— **Reference**: [RFC 2246](https://datatracker.ietf.org/doc/html/rfc2246)

## ğŸ“ **FTP (File Transfer Protocol)**

- **Layer**: Application Layer (Layer 7)
- **Ports**: TCP port **21** (commands) and **20** (data transfer)
- **Purpose**: Transfer files between client and server.
- **Security**: Unsecured by default; passwords sent in plaintext.

**Modes of Operation**:
1. **Active Mode**: Server connects back to the client using port 20 after receiving PORT command.
2. **Passive Mode (PASV)**: Client initiates both control and data connections (commonly used behind NAT/firewalls).

### ğŸ’¬ Common FTP Commands:
| Command | Description |
|---------|-------------|
| `USER`  | Username for authentication. |
| `PASS`  | Password for authentication. |
| `PORT`  | Sets up data connection in active mode. |
| `PASV`  | Requests passive mode from server. |
| `LIST`  | Lists files in the current directory. |
| `CWD`   | Changes working directory. |
| `PWD`   | Displays current directory path. |
| `SIZE`  | Returns file size. |
| `RETR`  | Downloads a file. |
| `QUIT`  | Ends the FTP session. |

ğŸ“Œ Most modern systems prefer **SFTP (Secure FTP)** or **FTPS** due to the security concerns with FTP.

ğŸ”— **Reference**: [RFC 959](https://datatracker.ietf.org/doc/html/rfc959)

## ğŸ–¥ï¸ **SMB (Server Message Block)**

- **Layer**: Application Layer (Layer 7)
- **Port**: TCP port 445 (modern), also NetBIOS ports 137-139 (legacy)
- **Purpose**: File and resource sharing (printers, files, authentication) primarily in Windows environments.
- **Security**: Requires authentication; supports signing and encryption in newer versions.

**How it works**:
- SMB establishes sessions using TCP (3-way handshake).
- Then, clients can authenticate and access shared resources like folders or printers.
- Uses **NTLM** or **Kerberos** for authentication.

### âš ï¸ Security Considerations:
- SMB is often targeted by attackers for **lateral movement** and **credential theft**.
- Monitoring SMB traffic (especially failed logins or unusual file access) is critical in network defense.

## âœ… Summary

| Protocol | Purpose | Port(s) | Secure Version |
|----------|---------|--------|----------------|
| HTTP     | Web browsing / data transfer | 80 / 8000 | HTTPS |
| HTTPS    | Encrypted web browsing | 443 / 8443 | Yes (TLS/SSL) |
| FTP      | File transfers | 20 (data), 21 (commands) | SFTP / FTPS |
| SMB      | File/printer/resource sharing | 445 | Yes (modern SMBv3+) |

---

Sure! Here's a clear and easy-to-understand **explanation** of the text you provided about **Network Traffic Analysis (NTA)**:

---

# ğŸ” **The Analysis Process**

**Network Traffic Analysis** is the process of carefully studying the data moving through a network. This data includes all the communications between computers, servers, and other devices. The goal is to understand whatâ€™s happening, detect anything unusual, and respond to potential threats or problems quickly.

## ğŸ” **Why Is It a Process?**

NTA is not a one-size-fits-all process. It depends on:
- The **tools** you have (like Wireshark, Splunk, ELK Stack, etc.).
- The **permissions** given by your organization (e.g., access to logs or internal devices).
- How much **visibility** you have into the network (can you see just one system, or the whole environment?).

Even though these things may change, the goal is to create a **repeatable, reliable process** for analyzing traffic each time.
## ğŸ§  **What Does Analysis Involve?**

When doing traffic analysis, you:
1. **Break down data into understandable parts** (like protocols, ports, IPs).
2. **Look for anything strange**, such as:
   - Unusual traffic patterns.
   - Connections from unknown or external IPs.
   - Unauthorized access (e.g., using RDP, SSH, or Telnet).
   - Spikes in traffic before a crash or system slowdown.

3. **Compare with a baseline** â€” the usual, healthy traffic behavior in your network. This helps you detect when somethingâ€™s off.

## ğŸ›¡ï¸ **Why Is It Important for Defense?**

Without NTA, youâ€™re basically **flying blind**. You wouldnâ€™t know:
- Which devices are talking the most (top talkers).
- Whether internal systems are communicating normally.
- If an attack is happening right now or already happened.

Traffic visibility lets you:
- Spot threats **before** they cause damage.
- **Fix problems fast**.
- Understand your network deeply.

## âš™ï¸ **Using Other Tools with NTA**

NTA gets even stronger when used with other tools, like:
- **IDS/IPS** (Intrusion Detection/Prevention Systems).
- **Firewalls**.
- **System logs** (from hosts or network devices).
- **SIEMs** like **Splunk** or **ELK Stack**.

These tools can alert you to known threats, based on **signatures** of known attacks or suspicious behavior.

## âš ï¸ **What About Day-to-Day Operations?**

NTA is not only for detecting attacks. It also helps with:
- **Troubleshooting** (e.g., why canâ€™t this machine connect?).
- **Monitoring protocol behavior** (e.g., is DNS working correctly?).
- **Diagnosing performance issues** (e.g., high latency or packet loss).

If you can see the traffic, you can **see where things go wrong**.

## ğŸ‘ï¸ **Donâ€™t Rely Only on Automation**

Tools are helpful, but theyâ€™re not perfect. Attackers are constantly learning how to bypass automated systems.

Thatâ€™s why:
- You should **use tools**, but also
- **Check things manually**, using your own eyes and judgment.

The **human analyst** is still the most powerful tool in cybersecurity.

## âœ… **Summary**

- NTA helps us understand what's happening on the network.
- It helps identify both security threats and operational issues.
- It works best when combined with other tools and human analysis.
- Donâ€™t rely only on automation â€” your skills and eyes are key to catching sophisticated threats.

---

# ğŸ§  **Understanding Analysis Dependencies**

Traffic analysis can be done in **two main ways**: **Passive** and **Active**.  
Each method has its own **requirements (or dependencies)** depending on how traffic is captured and analyzed.

### ğŸ”¹ **Passive Traffic Capture**
- You're **listening** to traffic without interfering.
- You **copy** data that is already flowing.
- No change to the network is needed.
- Often uses **mirrored ports** or **wireless sniffing** to see data.

### ğŸ”¹ **Active Traffic Capture**
- You place your tool **in-line**, like a checkpoint on a highway.
- You **intercept** traffic as it flows between devices.
- Requires **topology changes** (e.g., adding a tap or device in the network path).
- Provides more **real-time insight**, but more complex and risky.

## ğŸ“‹ **Table of Traffic Capture Dependencies**

| Dependency | Passive | Active | Explanation |
|------------|---------|--------|-------------|
| **Permission** | âœ… | âœ… | No matter which method, you must always get **written permission** from someone with authority. This is especially important in **sensitive industries** like healthcare or finance, where unauthorized traffic capture can be **illegal**. |
| **Mirrored Port** | âœ… | âŒ | Needed for passive mode. A **mirrored port** copies traffic from one port to another so your capture tool can read it. In wireless, you must connect to the **correct SSID** to see meaningful traffic. |
| **Capture Tools** | âœ… | âœ… | Tools like **Wireshark, TCPDump** help collect and analyze traffic. Be aware that **PCAP files grow fast** and may slow down your machine when filtered repeatedly. |
| **In-line Placement** | âŒ | âœ… | Required for active mode. You **insert** your tool into the path of network traffic like a "middle hop", so packets flow through it. Devices wonâ€™t notice it, but the network topology does. |
| **Network Tap or Dual NICs** | âŒ | âœ… | A **network tap** or a machine with **two NICs (network cards)** is needed to forward traffic while capturing. Best used on a **Layer 3 link** between network segments. |
| **Storage & Processing Power** | âœ… | âœ… | Both methods need **adequate disk space and CPU power**. Active mode may handle much more data, like trying to catch water from a firehose versus a sink faucet (passive). |

## ğŸ§­ **Why a Traffic Baseline Matters**

Even though not a strict "dependency", knowing what **normal traffic** looks like helps **speed up and improve analysis**.

Without a baseline, you have to:
- Inspect **every connection**
- Guess whatâ€™s normal vs suspicious
- Spend **hours filtering out noise**

With a baseline, you can:
- Instantly **ignore known-good** communication
- Focus only on **anomalies**
- React **faster** to threats

## ğŸ§ª **Real-World Example**

Youâ€™re a network admin at a big company. Suddenly:
- Some users report **slow networks**
- Strange **files appear** on desktops

You:
1. Connect to the affected network segment.
2. Start capturing traffic.
3. Stop after a few minutes and begin analyzing.

**Without a baseline:**
- Youâ€™re overwhelmed by the volume of data.
- You have to **check every single host and port** manually.
- You donâ€™t know whatâ€™s normal for this segment.

**With a baseline:**
- You quickly **filter out regular traffic**.
- You notice:
  - **Unusual traffic on ports 445 and 8080** between **user PCs**.
  - Normally, these ports are used between a user and a **server**, not peer-to-peer.
- This is suspicious and could mean **malware** or **lateral movement**.

Now, you can open a **trouble ticket** or escalate the incident **faster**, possibly preventing more damage.

## âš¡ Final Thoughts

- **Faster visibility = Less damage**
- Understand your **network flow** and **protocol behavior**
- Choose the **right capture method** based on your environment
- Build a **baseline** to detect threats faster and more accurately

---
Here's a **clear and structured explanation in English** of the content you provided, with helpful **emojis/icons** for better readability and engagement. This breakdown is ideal for learning, documentation, or training use.

---

## ğŸ” **Analysis in Practice**

In network security, traffic analysis is not a precise formulaic scienceâ€”it's a dynamic, context-driven process. The goal of this workflow is to guide analysts through various steps to detect, understand, and respond to network incidents, using a layered approach.
## ğŸ“˜ **Analysis Workflow Overview**

The workflow can be broken down into **four key types of analysis**:

### 1. ğŸ“Š Descriptive Analysis
**Goal:** Understand what is happening in the network.

- â“ **Whatâ€™s the issue?**  
  Example: A suspected data breach or strange traffic activity.

- ğŸ¯ **Define the scope & objective**  
  - **Target:** Hosts possibly downloading from `bad.example.com`  
  - **Timeframe:** Last 48 hours + 2 hours  
  - **Indicators:** Files like `superbad.exe`, `new-crypto-miner.exe`

- ğŸŒ **Define the target network/protocols**  
  - Subnet: `192.168.100.0/24`  
  - Protocols: HTTP and FTP

This stage answers the basic **who, what, when, and where** of the problem.

### 2. ğŸ› ï¸ Diagnostic Analysis  
**Goal:** Understand **why** something happened.

- ğŸ§ **Capture network traffic**  
  Use a tool like Wireshark or tcpdump on the affected subnet. Retrieve historical PCAP or NetFlow data from SIEM if available.

- ğŸš« **Filter irrelevant data**  
  Remove noiseâ€”focus on HTTP, FTP, or GET requests for the suspicious files.

- ğŸ” **Analyze traffic details**  
  - Look for file transfers using filters like `ftp-data`.  
  - HTTP: `http.request.method == "GET"`  
  - Identify which hosts downloaded malicious files.

This step **isolates causes** and helps **validate suspicions**.

### 3. ğŸ”® Predictive Analysis  
**Goal:** Forecast potential outcomes and prepare.

- ğŸ“ **Take notes & create mind maps**  
  Record:
  - Timeframes of captures
  - Suspicious host IPs
  - Packet/frame IDs of interest

- ğŸ§¾ **Summarize findings**  
  Present a concise explanation of what was discovered so decision-makers can act (e.g., quarantine infected machines).

This step prepares the analyst to **anticipate future incidents** or identify patterns of behavior.

### 4. ğŸ§ª Prescriptive Analysis  
**Goal:** Recommend actions based on data insights.

- ğŸ›¡ï¸ **Decide and act**  
  Example: Isolate hosts, patch vulnerabilities, monitor affected ports.

- ğŸ“š **Document lessons learned**  
  - What worked?
  - What failed?
  - What needs improvement?

This step strengthens **incident response** capabilities and reduces risk in future events.

## ğŸ§© **Key Components of Effective Analysis**

### 1. ğŸ—ºï¸ Know Your Environment  
Keep **network maps** and **asset inventories** updated. Knowing what "normal" looks like is critical to identifying anomalies.

### 2. ğŸ“ Sensor Placement  
Place traffic capture tools **near the issue source**. For example:
- Suspected internal attack â†’ monitor local subnet
- Internet-based attack â†’ monitor border gateway

### 3. ğŸ” Persistence  
Donâ€™t give up if you donâ€™t see the problem immediately. Some attacks (e.g., C2 callbacks) occur sporadically (e.g., every 12 hours).

## ğŸ§  **Smart Analysis Tips**

- ğŸ”Œ Start with **common protocols**: HTTP/S, FTP, DNS, Email
- ğŸ” Analyze **host-to-host traffic**: Rare in most networks unless justified
- ğŸ•µï¸ Spot **patterns**: Daily connections to external IPs can signal C2 activity
- ğŸ§¬ Look for **anomalies**:  
  - Rare ports in use  
  - Changes in User-Agent  
  - Sudden traffic spikes  
- ğŸ™‹â€â™‚ï¸ Ask for help when needed: Another analyst might catch something you missed.

## ğŸ§  Summary

Traffic analysis is **a cyclical, evolving process**â€”not a one-time job. Mastery involves:
- Knowing your network
- Efficient data filtering
- Strategic packet inspection
- Using tools like Wireshark, tcpdump, SIEM, and IDS (e.g., Snort, Suricata)

ğŸ›¡ï¸ Stay vigilant, keep improving, and make analysis **a habit, not just a reaction.**

---

# ğŸ“¡ **Tcpdump Primer**

## ğŸ§  **What is Tcpdump?**

**Tcpdump** is a command-line tool used for **packet sniffing** (capturing network packets). It allows you to:
- Capture packets directly from a **network interface** or from a **pcap file**.
- Work **without a GUI**, so it can be used via **terminal** or **SSH**.
- It's **very popular** on Unix-like operating systems such as Linux, BSD, macOS, etc.

> ğŸ’¡ **Note:** On Windows, a similar tool called **WinDump** used to exist, but it's no longer maintained. You can install Linux on Windows using WSL to run tcpdump.


## ğŸ“¦ **Installing and Checking Tcpdump**

### ğŸ” Check if it's installed:
```bash
which tcpdump
```
Usually found at `/usr/sbin/tcpdump`

### ğŸ“¥ Install tcpdump:
```bash
sudo apt install tcpdump
```

### âœ… Check the version:
```bash
sudo tcpdump --version
```

## ğŸ“¡ **Common Tcpdump Options**

| Option | Description |
|--------|-------------|
| `-D` | Show available network interfaces |
| `-i eth0` | Capture on a specific interface |
| `-n` | Do not resolve hostnames |
| `-nn` | Do not resolve hostnames or ports |
| `-e` | Show Ethernet header info |
| `-X` | Show packet contents in **hex + ASCII** |
| `-XX` | Like `-X` but includes Ethernet header |
| `-v`, `-vv`, `-vvv` | Increase verbosity level |
| `-c <number>` | Capture a specific number of packets then exit |
| `-s <size>` | Set snapshot length (packet size to capture) |
| `-S` | Display absolute TCP sequence numbers |
| `-q` | Quiet output (less detail) |
| `-w file.pcap` | Write packets to file |
| `-r file.pcap` | Read packets from file |

## ğŸ“Œ **Practical Examples**

### ğŸ–¥ï¸ Show available interfaces:
```bash
sudo tcpdump -D
```

### ğŸŒ Capture on eth0 interface:
```bash
sudo tcpdump -i eth0
```

### âŒ Disable DNS and port resolution:
```bash
sudo tcpdump -i eth0 -nn
```

### ğŸ“œ Show Ethernet header:
```bash
sudo tcpdump -i eth0 -e
```

### ğŸ” Show packet contents in **hex and ASCII**:
```bash
sudo tcpdump -i eth0 -X
```
## ğŸ“š **More Resources**
- View detailed manual:
```bash
man tcpdump
```

Sure! Here's a **clear explanation in English** of the `tcpdump` output section from your document, broken down for easy understanding:

---

## ğŸ“Š **Understanding Tcpdump Output**

When you run `tcpdump`, the output can look confusing at first. But each line is structured, and with some practice, you'll be able to quickly understand what itâ€™s telling you. Here's a breakdown of the key parts of each output line and what they mean.

### ğŸ§± Tcpdump Output Line Structure

![alt text](image-39.png)

Each line in `tcpdump` output typically contains the following fields:

| **Field**                    | **Color (in image)** | **Explanation** |
|-----------------------------|----------------------|-----------------|
| **Timestamp**               | ğŸŸ¡ Yellow            | Shows the **exact time** the packet was captured. You can configure this format. |
| **Protocol**                | ğŸŸ  Orange            | Tells you which **upper-layer protocol** is used. Example: `IP`, `ARP`, etc. |
| **Source & Destination IP.Port** | ğŸŸ  Orange        | Shows **who sent** the packet and **who received it**, including port numbers. Example: `172.16.146.2.21` |
| **Flags**                   | ğŸŸ¢ Green             | Displays **TCP flags** like SYN, ACK, FIN, etc. Useful for understanding TCP session states. |
| **Sequence & Acknowledgement Numbers** | ğŸ”´ Red | TCP uses these numbers to **track data segments** and ensure reliability. Relative numbers are shown by default. |
| **Protocol Options**        | ğŸ”µ Blue              | Any **negotiated TCP options** like window size, timestamps, or SACK (Selective Acknowledgment). |
| **Notes / Next Header**     | âšª White             | Additional information from `tcpdump` dissector, like detecting **application protocols** (e.g., FTP). |

> The **more verbose** you make your `tcpdump` command (using `-v`, `-vv`, or `-vvv`), the **more detailed** these fields become.

## ğŸ“ **File Input/Output with Tcpdump**

### ğŸ“ Save a capture to file:
```bash
sudo tcpdump -i eth0 -w ~/output.pcap
```

This command:
- Captures packets on `eth0`
- **Writes them directly to a file** (`output.pcap`)
- Does **not show anything on the terminal** during capture

Sample output:
```
tcpdump: listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes
10 packets captured
131 packets received by filter
0 packets dropped by kernel
```

This tells you:
- 10 packets matched your capture filter and were saved
- 131 total packets passed through the interface
- 0 packets were dropped by the OS

### ğŸ“– Read packets from a saved file:
```bash
sudo tcpdump -r ~/output.pcap
```

This command reads and displays the capture from `output.pcap`.

Example output:
```
11:15:40.321509 IP 172.16.146.2.57236 > ec2-99-80-22-207.eu-west-1.compute.amazonaws.com.https: Flags [P.], seq 2751910362:2751910399, ack 946558143, win 501, options [...], length 37
```

Letâ€™s break this line down:
- `11:15:40.321509`: Timestamp of the packet
- `IP`: Protocol
- `172.16.146.2.57236`: Source IP and port
- `>`: Indicates the direction (from source to destination)
- `ec2-99-80-22-207.eu-west-1.compute.amazonaws.com.https`: Destination (domain + port)
- `Flags [P.]`: TCP flags (PUSH + ACK in this case)
- `seq ... ack ...`: TCP sequence and acknowledgment numbers
- `win 501`: TCP window size
- `options [...]`: TCP options like timestamps
- `length 37`: Payload size in bytes

> You can reapply filters and verbosity options (like `-nn`, `-X`, `-v`) **when reading pcap files** to get more details.

## ğŸ›¡ï¸ Bonus: Tcpdump as a Mini IDS

You can use tcpdump creatively:
- Write a **Bash script** that reads packets from `tcpdump`
- Search for **specific patterns** (e.g., many ICMP echo requests)
- Take action like **banning an IP** if it looks suspicious

This is a **lightweight approach to IDS/IPS** (Intrusion Detection/Prevention System).

Example script snippet:
```bash
if [ $(tcpdump 'icmp' -c 100 | wc -l) -gt 50 ]; then
   sudo iptables -A INPUT -s <ip> -j DROP
fi
```
This script checks for **more than 50 ICMP packets** and blocks the source IP if it exceeds that threshold.

---

## **ğŸ“˜ Tcpdump Packet Filtering**

### **Overview of Tcpdump and Packet Filtering**

`Tcpdump` is a powerful command-line tool used to capture and analyze network traffic. However, when working with high volumes of traffic, capturing everything isn't practical. Thatâ€™s where **packet filters** come inâ€”they help us capture only the specific data we care about.

### **Benefits of Packet Filtering**
- Reduces the number of packets saved to files.
- Lowers buffer usage.
- Improves analysis efficiency.
- Allows you to focus on specific targets (host, port, protocol, etc.).

## ğŸ›  **Useful Tcpdump Filters**

| **Filter**          | **Description**                                                                   |
|---------------------|------------------------------------------------------------------------------------|
| `host`              | Captures all packets involving a specific host (IP or hostname).                  |
| `src` / `dst`       | Filters by source or destination IP address.                                      |
| `net`               | Filters packets within a specific network (CIDR format, e.g., `192.168.1.0/24`).  |
| `proto`             | Filters by protocol like `tcp`, `udp`, or `icmp`.                                 |
| `port`              | Filters packets by source or destination port.                                    |
| `portrange`         | Filters packets within a port range (e.g., `0-1024`).                             |
| `less` / `greater`  | Filters by packet size (less than or greater than a specified value).             |
| `and`, `or`, `not`  | Logical operators used to combine or negate filter conditions.                    |

## ğŸ“Œ **Examples and Syntax**

### ğŸ”¹ Filter by Host
```bash
sudo tcpdump -i eth0 host 172.16.146.2
```
Displays all traffic **to and from** the IP address `172.16.146.2`.

### ğŸ”¹ Filter by Source IP
```bash
sudo tcpdump -i eth0 src host 172.16.146.2
```
Displays packets **originating from** `172.16.146.2`.

### ğŸ”¹ Filter by Source Port
```bash
sudo tcpdump -i eth0 tcp src port 80
```
Shows packets where the **source port is 80**â€”typically HTTP server responses.

### ğŸ”¹ Filter by Destination Network
```bash
sudo tcpdump -i eth0 dst net 172.16.146.0/24
```
Captures all packets with a **destination IP in the `172.16.146.0/24` network**.

### ğŸ”¹ Filter by Protocol
```bash
sudo tcpdump -i eth0 udp
```
Or using protocol number:
```bash
sudo tcpdump -i eth0 proto 17
```
Both capture **UDP traffic** (protocol number 17).

## ğŸ’¡ **Combining Multiple Filters**

You can mix and match filters for more precise results:

- `tcp and src port 443 and dst host 172.16.146.2`
- `not udp and port 53`

## ğŸ“š **Tips for Using Tcpdump Effectively**
- Use `-v`, `-vv`, or `-vvv` for more verbose output.
- Use `-w filename.pcap` to save packets for later analysis in Wireshark.
- Use `-c <number>` to limit the number of packets captured.



## ğŸ” **Pre-Capture Filters vs. Post-Capture Processing**

### âœ… **Pre-Capture Filters**:
- Applied **before and during packet capturing**.
- Any traffic that does **not match the filter will be discarded** and never written to the capture file.
- â• **Pros**:
  - Reduces file size.
  - Improves performance when troubleshooting a specific issue.
- â– **Cons**:
  - Risk of **losing important data** that might be useful later.
  - Cannot recover dropped packets once captured.

### âœ… **Post-Capture Processing**:
- Applied **after packets have already been captured** and saved to a `.pcap` file.
- All packets are stored; the filter only affects what is **displayed or analyzed**.
- â• **Pros**:
  - Full data remains available for further analysis.
  - Flexible: you can apply different filters repeatedly.
- â– **Cons**:
  - Larger file size may slow down analysis.

## ğŸ§  **Tcpdump Tips and Useful Options**

| **Option** | **Description** |
|------------|------------------|
| `-S`       | Show **absolute TCP sequence numbers** (long and precise). By default, tcpdump uses relative numbers (shorter and easier to read). |
| `-v`, `-vv`, `-vvv` | Increase verbosity level (more details). |
| `-X`       | Display both **Hex and ASCII** output of packet payload. |
| `-A`       | Display **ASCII** output only (useful for readable strings). |
| `-c <num>` | Capture only `<num>` packets, then stop. |
| `-n`       | Don't resolve IP addresses to hostnames (faster output). |
| `-s 0`     | Capture the **full packet**, not just the default portion. |
| `-l`       | Use **line-buffered output**: essential for piping to tools like `grep`. |
| `-e`       | Show Ethernet header (Layer 2). |
| `-q`       | Quiet output: show only minimal information. |

### ğŸ“¥ **Example: View ASCII Content from a Capture File**

```bash
sudo tcpdump -Ar telnet.pcap
```
- `-A`: show only ASCII output.
- `-r`: read from `telnet.pcap`.
- â¡ï¸ Useful for spotting readable messages such as:
  - Login info.
  - System banners.
  - Commands typed during Telnet sessions.

### ğŸ” **Pipe a Capture to Grep (Keyword Search)**

```bash
sudo tcpdump -Ar http.cap -l | grep 'mailto:*'
```

- `-l`: enables real-time output for piping.
- `grep`: searches for lines with email addresses (`mailto:`).
- â¡ï¸ This method is effective for **scraping email addresses or specific strings** from captured traffic.

### âš™ï¸ **Filtering TCP SYN Flags (Detecting Connection Attempts)**

```bash
sudo tcpdump -i eth0 'tcp[13] & 2 != 0'
```

- `tcp[13]`: refers to the 13th byte of the TCP header (which contains flags).
- `& 2 != 0`: checks whether the **SYN flag** is set (bit 1).
- â¡ï¸ Filters packets **initiating TCP connections** (useful for detecting scans or new sessions).

### ğŸ“˜ **Protocol Reference (RFC Links)**

| **Protocol** | **RFC** | **Description** |
|--------------|---------|------------------|
| IP           | RFC 791 | Defines the Internet Protocol (IP). |
| ICMP         | RFC 792 | Used for diagnostics (e.g., ping). |
| TCP          | RFC 793 | Describes how TCP functions. |
| UDP          | RFC 768 | Defines the User Datagram Protocol. |
| RFC Index    | Wikipedia | Contains a full list of protocols and their associated RFCs. |

### âœ… **Summary**

**Tcpdump** is a powerful tool when combined with networking knowledge. Understanding how protocols are structured, using **pre- and post-capture filters**, applying **flags**, and combining with tools like `grep` allows for effective and efficient packet analysis.

---
## ğŸ“¡ **Interrogating Network Traffic With Capture and Display Filters**

## ğŸ” **Lab Goal**
This lab trains you to analyze `.pcap` files using **`tcpdump`**. Youâ€™ll apply different **filters** (by host, port, protocol, etc.) to better understand **DNS** and **HTTP/HTTPS** traffic in a corporate network. You'll answer questions like:

- Who are the DNS and web servers?
- What protocols are used?
- What websites were visited?
- What records or requests were made?

## ğŸ§ª **Task-by-Task Breakdown**


### âœ… **Task 1: Read a .pcap file without filters**
**Goal:** Just open the file and see all packets.

ğŸ“Œ **Command**:
```bash
tcpdump -r file.pcap
```
> This reads the file from disk and shows raw packet data â€” no filters yet.

### âœ… **Task 2: Identify types of traffic**
**Goal:** Recognize protocols and ports.

ğŸ‘€ Look for:
- **Protocols**: DNS, HTTP, HTTPS.
- **Ports used**:
  - DNS: `53`
  - HTTP: `80`
  - HTTPS: `443`

ğŸ’¡ Tip: You can filter traffic like:
```bash
tcpdump -r file.pcap port 80
```
To focus only on HTTP traffic.

### âœ… **Task 3: Identify conversations**
**Goal:** Find out which devices are talking to each other.

ğŸ” Questions to ask:
- Which IP is the **client** and which is the **server**?
- What ports are used in a **TCP handshake** (SYN â†’ SYN-ACK â†’ ACK)?
- Use `-S` to show **absolute TCP sequence numbers** for better tracking:
```bash
tcpdump -r file.pcap -S
```
ğŸ’¡ **Hint**: Servers often use well-known ports (like 80), while clients use random high ports.

### âœ… **Task 4: In-depth packet interpretation**
**Goal:** Analyze specific details.

ğŸ” What to find:
- **Timestamp** of first TCP connection: look for the first SYN-SYN/ACK-ACK.
- **IP of apache.org**: check DNS responses.
- **Protocol used in first conversation**: HTTP (port 80)? HTTPS (443)?

ğŸ’¡ Commands:
```bash
tcpdump -r file.pcap -nn  # disables DNS & port name resolution
```
Filter DNS replies:
```bash
tcpdump -r file.pcap port 53 and udp
```

### âœ… **Task 5: Filter only DNS traffic**
**Goal:** Focus on DNS requests/responses.

ğŸ“Œ **Command**:
```bash
tcpdump -r file.pcap udp and port 53
```
Then:
- Who is the **DNS server**?
- What **domain names** were requested?
- What kind of **DNS records**? (e.g., A, AAAA, MX)

ğŸ’¡ Use `-X` to see the Hex and ASCII parts:
```bash
tcpdump -r file.pcap -X udp and port 53
```

### âœ… **Task 6: Filter for web traffic (HTTP/HTTPS)**
**Goal:** Detect websites visited & webserver behavior.

ğŸ“Œ **Commands**:
```bash
tcpdump -r file.pcap port 80 or port 443
```
Look for:
- **Web pages requested** (from GET or POST requests).
- Common **HTTP methods** (GET, POST).
- Common **HTTP responses** (200 OK, 404 Not Found, etc.).

### âœ… **Task 7: Investigate the first webserver**
**Goal:** Learn about the web server software & OS.

ğŸ“Œ Tip:
Use `-X` to view ASCII details in server responses:
```bash
tcpdump -r file.pcap -X port 80
```
Server banners might reveal:
- **Web server software**: Apache, Nginx, etc.
- **Operating system**.

âš ï¸ Harder to do with `tcpdump` alone â€” easier in **Wireshark**.

### ğŸ“ **Summary of Skills Gained**
- Use `tcpdump` to read `.pcap` files.
- Apply **filters** to narrow down traffic by:
  - Host
  - Port
  - Protocol
- Identify:
  - DNS/Web servers
  - Protocol types
  - Connection flows
  - DNS records
  - HTTP request/response info
- Understand network behavior in a real environment.

### ğŸ’¡ Analysis Questions to Guide You:
- What **types of traffic** are visible (TCP, UDP, HTTP, DNS)?
- How many **unique conversations**?
- How many **hosts** are involved?
- What is the **first TCP connection** seen?
- Which **traffic can be filtered** to reduce noise?
- Who are the **servers** (based on well-known ports)?
- What **DNS records** or **HTTP methods** were used?

